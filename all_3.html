<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Methol
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Methol" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">Methol</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-09-06T09:00:45+08:00" itemprop="datePublished">2015/09/06</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="16661412450464.html" itemprop="url">
		shadowsocks用户连接数查看脚本</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<pre><code class="language-shell">#!/bin/bash
cd ~
echo  &gt;shadowsocks_clients.txt
for ((i=9101; i&lt;9105; i++)); do
echo ${i}: &gt;&gt;shadowsocks_clients.txt
lsof -i -n -P | egrep -c &quot;:${i}.+ESTABLISHED&quot;  &gt;&gt;shadowsocks_clients.txt
lsof -i -n -P | egrep &quot;:${i}.+ESTABLISHED&quot;  &gt;&gt;shadowsocks_clients.txt
echo  &gt;&gt;shadowsocks_clients.txt
echo  &gt;&gt;shadowsocks_clients.txt
done

cat shadowsocks_clients.txt
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-07-24T09:00:44+08:00" itemprop="datePublished">2015/07/24</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="16661412449730.html" itemprop="url">
		单例模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3><a id="%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><del>懒汉式，线程不安全</del></h3>
<p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p>
<pre><code class="language-java">public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static Singleton getInstance() {
     if (instance == null) {
         instance = new Singleton();
     }
     return instance;
    }
}
</code></pre>
<p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p>
<h3><a id="%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>懒汉式，线程安全</h3>
<p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（==synchronized==）。</p>
<pre><code class="language-java">public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
</code></pre>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p>
<h3><a id="%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双重检验锁</h3>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查<code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p>
<pre><code class="language-java">public static Singleton getSingleton() {
    if (instance == null) {   //Single Checked
        synchronized (Singleton.class) {
            if (instance == null) {   //Double Checked
                instance = new Singleton();
            }
        }
    }
    return instance ;
}
</code></pre>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ul>
<li>1.给 instance 分配内存</li>
<li>2.调用 Singleton 的构造函数来初始化成员变量</li>
<li>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ul>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<pre><code class="language-java">public class Singleton {
    private volatile static Singleton instance; //声明成 volatile
    private Singleton (){}

    public static Singleton getSingleton() {
        if (instance == null) {                         
            synchronized (Singleton.class) {
                if (instance == null) {       
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}
</code></pre>
<p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p>
<p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p>
<h3><a id="%E9%A5%BF%E6%B1%89%E5%BC%8Fstatic-final-field" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>饿汉式 static final field</h3>
<p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>
<pre><code class="language-java">public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;
    }  
}
</code></pre>
<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h3><a id="%E6%9E%9A%E4%B8%BEenum" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举 Enum</h3>
<p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p>
<pre><code class="language-java">public enum EasySingleton{
    INSTANCE;
}
</code></pre>
<p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p>
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。<br />
就我个人而言，一般情况下直接使用==<strong>饿汉式</strong>==就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用==<strong>静态内部类</strong>==，如果涉及到反序列化创建对象时会试着使用==<strong>枚举</strong>==的方式来实现单例。</p>
<h3><a id="read-more" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Read More</h3>
<blockquote>
<ul>
<li><a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html">Double Checked Locking on Singleton Class in Java</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html">Why Enum Singleton are better in Java</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html">How to create thread safe Singleton in Java</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html">10 Singleton Pattern Interview questions in Java</a></li>
</ul>
</blockquote>
<p>转载：</p>
<blockquote>
<p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式 | Jark's Blog</a></p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-05-10T09:00:45+08:00" itemprop="datePublished">2015/05/10</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="16661412450535.html" itemprop="url">
		k-means聚类算法</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>聚类分析算法的一个java代码，我的项目中应用了这个代码。</p>
<pre><code class="language-java">package com.methol.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

//K-means算法实现

public class KMeans {
    // 聚类的数目
    public final static int ClassCount = 4;
    // 样本数目（测试集）
    public static int InstanceNumber = 100;
    // 样本属性数目（测试）
    public final static int FieldCount = 1;

    // 设置异常点阈值参数（每一类初始的最小数目为InstanceNumber/ClassCount^t）
    public final static double t = 2.0;
    // 存放数据的矩阵
    public static double[][] data;

    // 每个类的均值中心
    public static double[][] classData;

    // 噪声集合索引
    public static ArrayList&lt;Integer&gt; noises;

    // 存放每次变换结果的矩阵
    public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result;

    //存放每个属性的最大值
    public static double[] classmax = new double[FieldCount];

    // 构造函数，初始化
    public KMeans() {
        // 最后一位用来储存结果
        data = new double[InstanceNumber][FieldCount + 1];
        classData = new double[ClassCount][FieldCount];
        result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(ClassCount);
        noises = new ArrayList&lt;Integer&gt;();
    }

    /**
     * 主函数入口 测试集的文件名称为“测试集.data”,其中有1000*57大小的数据 每一行为一个样本，有57个属性 主要分为两个步骤 1.读取数据
     * 2.进行聚类 最后统计运行时间和消耗的内存
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        long startTime = System.currentTimeMillis();
        KMeans cluster = new KMeans();
        cluster.InstanceNumber = 100;
        // 读取数据
        //cluster.readData(&quot;D:/test.txt&quot;);

        //随机产生数据
        for (int i = 0; i &lt; InstanceNumber; i++) {
            data[i][0] = (double) Math.random();
            data[i][0] = data[i][0] * 100;
            System.out.println(data[i][0]);
        }

        // 聚类过程
        cluster.cluster();
        // 输出结果
        cluster.printResult(&quot;clusterResult.data&quot;);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;Total Time:&quot; + (endTime - startTime) + &quot;ms&quot;);
        System.out.println(&quot;Memory Consuming:&quot;
                + (double) (Runtime.getRuntime().totalMemory() - Runtime
                .getRuntime().freeMemory()) / 1000000 + &quot;MB&quot;);

        System.out.println(&quot;聚类中心：&quot;);
        for (int i = 0; i &lt; ClassCount; i++) {
            System.out.println(classData[i][0] * classmax[0]);

            //data[i][0] = (double) (Math.random()*100);
        }

        for (ArrayList&lt;Integer&gt; i : result) {
            for (Integer integer : i) {
                System.out.print(integer + &quot;\t&quot;);
            }
            System.out.println(&quot;数目:&quot; + i.size());
        }

        for (ArrayList&lt;Integer&gt; i : result) {
            for (Integer integer : i) {
                System.out.print(data[integer][0] + &quot;\t&quot;);
            }
            System.out.println(&quot;数目:&quot; + i.size());
        }

        System.out.println(&quot;noises:&quot;);
        for (Integer noise : noises) {
            System.out.println(noise);
        }
    }

    /**
     * 读取测试集的数据
     *
     * @param trainingFileName 测试集文件名
     */
    public void readData(String trainingFileName) {
        try {
            FileReader fr = new FileReader(trainingFileName);
            BufferedReader br = new BufferedReader(fr);
            // 存放数据的临时变量
            String lineData = null;
            String[] splitData = null;
            int line = 0;
            // 按行读取
            while (br.ready()) {
                // 得到原始的字符串
                lineData = br.readLine();
                splitData = lineData.split(&quot;,&quot;);
                // 转化为数据
                // System.out.println(&quot;length:&quot;+splitData.length);
                if (splitData.length &gt; 1) {
                    for (int i = 0; i &lt; splitData.length; i++) {
                        // System.out.println(splitData[i]);
                        // System.out.println(splitData[i].getClass());
                        if (splitData[i].startsWith(&quot;Iris-setosa&quot;)) {
                            data[line][i] = (double) 1.0;
                        } else if (splitData[i].startsWith(&quot;Iris-versicolor&quot;)) {
                            data[line][i] = (double) 2.0;
                        } else if (splitData[i].startsWith(&quot;Iris-virginica&quot;)) {
                            data[line][i] = (double) 3.0;
                        } else { // 将数据截取之后放进数组
                            data[line][i] = Double.parseDouble(splitData[i]);
                        }
                    }
                    line++;
                }
            }
            System.out.println(line);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 聚类过程，主要分为两步 1.循环找初始点 2.不断调整直到分类不再发生变化
     */
    public void cluster() {
        // 数据标准化处理
        normalize();
        // 标记是否需要重新找初始点
        boolean needUpdataInitials = true;

        // 找初始点的迭代次数
        int times = 1;
        // 找初始点
        while (needUpdataInitials) {
            needUpdataInitials = false;
            result.clear();
            //System.out.println(&quot;Find Initials Iteration&quot; + (times++) + &quot;time(s)&quot;);

            // 一次找初始点的尝试和根据初始点的分类
            findInitials();
            firstClassify();

            // 如果某个分类的数目小于特定的阈值，则认为这个分类中的所有样本都是噪声点
            // 需要重新找初始点
            for (int i = 0; i &lt; result.size(); i++) {
                if (result.get(i).size() &lt; InstanceNumber
                        / Math.pow(ClassCount, t)) {
                    needUpdataInitials = true;
                    noises.addAll(result.get(i));
                }
            }
        }

        // 找到合适的初始点后
        // 不断的调整均值中心和分类，直到不再发生任何变化
        Adjust();

//        //把结果存入数组answer中
//        for (int i = 0; i &lt; ClassCount; i++) {
//            KMeans.answer[i] = classData[i][0];
//        }

    }

    /**
     * 对数据进行归一化 1.找每一个属性的最大值 2.对某个样本的每个属性除以其最大值
     */
    public void normalize() {
        // 找最大值

        for (int i = 0; i &lt; InstanceNumber; i++) {
            for (int j = 0; j &lt; FieldCount; j++) {
                if (data[i][j] &gt; classmax[j])
                    classmax[j] = data[i][j];
            }
        }

        // 归一化
        for (int i = 0; i &lt; InstanceNumber; i++) {
            for (int j = 0; j &lt; FieldCount; j++) {
                data[i][j] = data[i][j] / classmax[j];
            }
        }
    }

    // 关于初始向量的一次找寻尝试
    public void findInitials() {
        // a,b为标志距离最远的两个向量的索引
        int i, j, a, b;
        i = j = a = b = 0;

        // 最远距离
        double maxDis = 0;

        // 已经找到的初始点个数
        int alreadyCls = 2;

        // 存放已经标记为初始点的向量索引
        ArrayList&lt;Integer&gt; initials = new ArrayList&lt;Integer&gt;();

        // 从两个开始
        for (; i &lt; InstanceNumber; i++) {
            // 噪声点
            if (noises.contains(i))
                continue;
            // long startTime = System.currentTimeMillis();
            j = i + 1;
            for (; j &lt; InstanceNumber; j++) {
                // 噪声点
                if (noises.contains(j))
                    continue;
                // 找出最大的距离并记录下来
                double newDis = calDis(data[i], data[j]);
                if (maxDis &lt; newDis) {
                    a = i;
                    b = j;
                    maxDis = newDis;
                }
            }
            // long endTime = System.currentTimeMillis();
            // System.out.println(i +
            // &quot;Vector Caculation Time:&quot;+(endTime-startTime)+&quot;ms&quot;);
        }

        // 将前两个初始点记录下来
        initials.add(a);
        initials.add(b);
        classData[0] = data[a];
        classData[1] = data[b];

        // 在结果中新建存放某样本索引的对象，并把初始点添加进去
        ArrayList&lt;Integer&gt; resultOne = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; resultTwo = new ArrayList&lt;Integer&gt;();
        resultOne.add(a);
        resultTwo.add(b);
        result.add(resultOne);
        result.add(resultTwo);

        // 找到剩余的几个初始点
        while (alreadyCls &lt; ClassCount) {
            i = j = 0;
            double maxMin = 0;
            int newClass = -1;

            // 找最小值中的最大值
            for (; i &lt; InstanceNumber; i++) {
                double min = 0;
                double newMin = 0;
                // 找和已有类的最小值
                if (initials.contains(i))
                    continue;
                // 噪声点去除
                if (noises.contains(i))
                    continue;
                for (j = 0; j &lt; alreadyCls; j++) {
                    newMin = calDis(data[i], classData[j]);
                    if (min == 0 || newMin &lt; min)
                        min = newMin;
                }

                // 新最小距离较大
                if (min &gt; maxMin) {
                    maxMin = min;
                    newClass = i;
                }
            }
            // 添加到均值集合和结果集合中
            // System.out.println(&quot;NewClass&quot;+newClass);
            initials.add(newClass);
            //System.err.println(&quot;newClass:&quot;+newClass);
            //System.err.println(&quot;alreadyCls:&quot;+alreadyCls);
            classData[alreadyCls++] = data[newClass];
            ArrayList&lt;Integer&gt; rslt = new ArrayList&lt;Integer&gt;();
            rslt.add(newClass);
            result.add(rslt);
        }
    }

    // 第一次分类
    public void firstClassify() {
        // 根据初始向量分类
        for (int i = 0; i &lt; InstanceNumber; i++) {
            double min = 0f;
            int clsId = -1;
            for (int j = 0; j &lt; classData.length; j++) {
                // 欧式距离
                double newMin = calDis(classData[j], data[i]);
                if (clsId == -1 || newMin &lt; min) {
                    clsId = j;
                    min = newMin;
                }

            }
            // 本身不再添加
            if (!result.get(clsId).contains(i))
                result.get(clsId).add(i);
        }
    }

    // 迭代分类，直到各个类的数据不再变化
    public void Adjust() {
        // 记录是否发生变化
        boolean change = true;

        // 循环的次数
        int times = 1;
        while (change) {
            // 复位
            change = false;
            //System.out.println(&quot;Adjust Iteration&quot; + (times++) + &quot;time(s)&quot;);

            // 重新计算每个类的均值
            for (int i = 0; i &lt; ClassCount; i++) {
                // 原有的数据
                ArrayList&lt;Integer&gt; cls = result.get(i);

                // 新的均值
                double[] newMean = new double[FieldCount];

                // 计算均值
                for (Integer index : cls) {
                    for (int j = 0; j &lt; FieldCount; j++)
                        newMean[j] += data[index][j];
                }
                for (int j = 0; j &lt; FieldCount; j++)
                    newMean[j] /= cls.size();
                if (!compareMean(newMean, classData[i])) {
                    classData[i] = newMean;
                    change = true;
                }
            }
            // 清空之前的数据
            for (ArrayList&lt;Integer&gt; cls : result)
                cls.clear();

            // 重新分配
            for (int i = 0; i &lt; InstanceNumber; i++) {
                double min = 0f;
                int clsId = -1;
                for (int j = 0; j &lt; classData.length; j++) {
                    double newMin = calDis(classData[j], data[i]);
                    if (clsId == -1 || newMin &lt; min) {
                        clsId = j;
                        min = newMin;
                    }
                }
                data[i][FieldCount] = clsId;
                result.get(clsId).add(i);
            }

            // 测试聚类效果(训练集)
            // for(int i = 0;i &lt; ClassCount;i++){
            // int positives = 0;
            // int negatives = 0;
            // ArrayList&lt;Integer&gt; cls = result.get(i);
            // for(Integer instance:cls)
            // if (data[instance][FieldCount - 1] == 1f)
            // positives ++;
            // else
            // negatives ++;
            // System.out.println(&quot; &quot; + i + &quot; Positive: &quot; + positives +
            // &quot; Negatives: &quot; + negatives);
            // }
            // System.out.println();
        }

    }

    /**
     * 计算a样本和b样本的欧式距离作为不相似度
     *
     * @param aVector 样本a
     * @param bVector 样本b
     * @return 欧式距离长度
     */
    private double calDis(double[] aVector, double[] bVector) {
        double dis = 0;
        int i = 0;
        /* 最后一个数据在训练集中为结果，所以不考虑 */
        for (; i &lt; aVector.length; i++)
            dis += Math.pow(bVector[i] - aVector[i], 2);
        dis = Math.pow(dis, 0.5);
        return (double) dis;
    }

    /**
     * 判断两个均值向量是否相等
     *
     * @param a 向量a
     * @param b 向量b
     * @return 相等返回true
     */
    private boolean compareMean(double[] a, double[] b) {
        if (a.length != b.length)
            return false;
        for (int i = 0; i &lt; a.length; i++) {
            if (a[i] &gt; 0 &amp;&amp; b[i] &gt; 0 &amp;&amp; a[i] != b[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * 将结果输出到一个文件中
     *
     * @param fileName 文件名
     */
    public void printResult(String fileName) {
        FileWriter fw = null;
        BufferedWriter bw = null;
        try {
            fw = new FileWriter(fileName);
            bw = new BufferedWriter(fw);
            // 写入文件
            for (int i = 0; i &lt; InstanceNumber; i++) {
                bw.write(String.valueOf(data[i][FieldCount]).substring(0, 1));
                bw.newLine();
            }

            // 统计每类的数目，打印到控制台
            for (int i = 0; i &lt; ClassCount; i++) {
                System.out.println(&quot;第&quot; + (i + 1) + &quot;类数目: &quot;
                        + result.get(i).size());
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            // 关闭资源
            if (bw != null)
                try {
                    bw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            if (fw != null)
                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
        }

    }
}

</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_2.html">Prev</a>  
	 <a class="next" href="all_4.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>



  














<style type="text/css">
figure{margin: 1em 0;padding: 0;}
  figcaption{text-align:center;}

/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-coy&languages=markup+css+clike+javascript */
/**
 * prism.js Coy theme for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/tshedor/workshop-wp-theme (Example: http://workshop.kansan.com/category/sessions/basics or http://workshop.timshedor.com/category/sessions/basics);
 * @author Tim  Shedor
 */

code[class*="language-"],
pre[class*="language-"] {
  color: black;
  background: none;
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  position: relative;
  margin: .5em 0;
  overflow: visible;
  padding: 0;
}
pre[class*="language-"]>code {
  position: relative;
  border-left: 10px solid #358ccb;
  box-shadow: -1px 0px 0px 0px #358ccb, 0px 0px 0px 1px #dfdfdf;
  background-color: #fdfdfd;
  background-image: linear-gradient(transparent 50%, rgba(69, 142, 209, 0.04) 50%);
  background-size: 3em 3em;
  background-origin: content-box;
  background-attachment: local;
}

code[class*="language"] {
  max-height: inherit;
  height: inherit;
  padding: 0 1em;
  display: block;
  overflow: auto;
}

/* Margin bottom to accomodate shadow */
:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdfdfd;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  margin-bottom: 1em;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  position: relative;
  padding: .2em;
  border-radius: 0.3em;
  color: #c92c2c;
  border: 1px solid rgba(0, 0, 0, 0.1);
  display: inline;
  white-space: normal;
}

pre[class*="language-"]:before,
pre[class*="language-"]:after {
  content: '';
  z-index: -2;
  display: block;
  position: absolute;
  bottom: 0.75em;
  left: 0.18em;
  width: 40%;
  height: 20%;
  max-height: 13em;
  box-shadow: 0px 13px 8px #979797;
  -webkit-transform: rotate(-2deg);
  -moz-transform: rotate(-2deg);
  -ms-transform: rotate(-2deg);
  -o-transform: rotate(-2deg);
  transform: rotate(-2deg);
}

:not(pre) > code[class*="language-"]:after,
pre[class*="language-"]:after {
  right: 0.75em;
  left: auto;
  -webkit-transform: rotate(2deg);
  -moz-transform: rotate(2deg);
  -ms-transform: rotate(2deg);
  -o-transform: rotate(2deg);
  transform: rotate(2deg);
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #7D8B99;
}

.token.punctuation {
  color: #5F6364;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.function-name,
.token.constant,
.token.symbol,
.token.deleted {
  color: #c92c2c;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.function,
.token.builtin,
.token.inserted {
  color: #2f9c0a;
}

.token.operator,
.token.entity,
.token.url,
.token.variable {
  color: #a67f59;
  background: rgba(255, 255, 255, 0.5);
}

.token.atrule,
.token.attr-value,
.token.keyword,
.token.class-name {
  color: #1990b8;
}

.token.regex,
.token.important {
  color: #e90;
}

.language-css .token.string,
.style .token.string {
  color: #a67f59;
  background: rgba(255, 255, 255, 0.5);
}

.token.important {
  font-weight: normal;
}

.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}

.namespace {
  opacity: .7;
}

@media screen and (max-width: 767px) {
  pre[class*="language-"]:before,
  pre[class*="language-"]:after {
    bottom: 14px;
    box-shadow: none;
  }

}

/* Plugin styles */
.token.tab:not(:empty):before,
.token.cr:before,
.token.lf:before {
  color: #e0d7d1;
}

/* Plugin styles: Line Numbers */
pre[class*="language-"].line-numbers.line-numbers {
  padding-left: 0;
}

pre[class*="language-"].line-numbers.line-numbers code {
  padding-left: 3.8em;
}

pre[class*="language-"].line-numbers.line-numbers .line-numbers-rows {
  left: 0;
}

/* Plugin styles: Line Highlight */
pre[class*="language-"][data-line] {
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 0;
}
pre[data-line] code {
  position: relative;
  padding-left: 4em;
}
pre .line-highlight {
  margin-top: 0;
}

pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>